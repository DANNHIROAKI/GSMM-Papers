# 1. AVL Tree

## 1.0. 前置知识: 二叉树的删除操作

:one:删除节点是叶节点：直接删除

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240708214410114.png" alt="image-20240708214410114" style="zoom: 67%;" />  

:two:节点只有一个子树：删除本节点，其拥有的一个子树往上接(父债子偿)

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240708215544370.png" alt="image-20240708215544370" style="zoom: 67%;" />   

:three:节点有两个子树：删除本结点，并用中根遍历的上个/下个节点代替

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240708215720017.png" alt="image-20240708215720017" style="zoom:67%;" />   

中根遍历：3→7→23→32→35→40→54→100

## 1.1. AVL树概念

:one:节点的平衡因子：节点左子树深度$-$节点右子树深度

:two:AVL概念：二叉树$+$每个节点平衡因子都在$\{-1,0,1\}$​范围内​​

## 1.2. 普通二叉树$\to$平衡二叉树

:one:左子树左高：根右旋

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/e630cdec01f3f2037a090ad0a4a0a6d9.png" alt="e630cdec01f3f2037a090ad0a4a0a6d9" style="zoom: 22%;" />   

:two:左子树右高：左子树左旋，根右旋

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/3ca8d63aaca205482cc5fc2845882831.png" alt="3ca8d63aaca205482cc5fc2845882831" style="zoom: 22%;" /> 

:three:右子树右高：根左旋​

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240708225929227.png" alt="image-20240708225929227" style="zoom: 35%;" /> 

:four:右子树左高：右子树右旋，根左旋

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240708231524438.png" alt="image-20240708231524438" style="zoom:35%;" /> 

## 1.3. 平衡二叉树的删除/插入

:one:步骤：​按照二叉树的插入/删除规律插入/删除→平衡化处理

:two:示例：

1. 删除，左子树右高

   <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240708233048155.png" alt="image-20240708233048155" style="zoom:30%;" /> 

2. 插入，右子树左高

   <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240708234235562.png" alt="image-20240708234235562" style="zoom:35%;" /> 

3. 删除，多次平衡化处理

   <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240708235122002.png" alt="image-20240708235122002" style="zoom: 33%;" />   

## 1.4. 平衡而二叉树的应用

:one:条件

1. 存在两个无序序列$S,T$
2. 对于$x\in{}S$，定义其后继$succ(x)$为$S$中大于$x$的最小值
3. 现在需要找到$S$中的所有数$x_1$，满足区间$[x_1,succ(x_1)]$区间内不含任何$T$中的数
4. 算法的时间复杂度要为$O((|S|+|T|)\log{}n)$

:two:示例：对于$S=\{50,30,80,20,100\},\,T=\{15,17,9,83,55,56,42\}$

1. 合法输出：$20$和$100$，因为二者对应区间$[20,30]$和$[100,\infin]$，这两个区间中不含有任何$T$中元素
2. 非法输出示例：$30$，对应区间$[30,50]$，对应有$T$中元素$42$ 

# 2. 优先队列与堆

## 2.1. 基本概念

:one:优先队列：至少包含两种操作

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240709214003167.png" alt="image-20240709214003167" style="zoom:50%;" />  

:two:堆：优先队列的实现

1. 结构：是一颗完全二叉树，即满二叉树从右下角从右往左删除几个元素

   <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240709214605420.png" alt="image-20240709214605420" style="zoom: 40%;" />   

2. 堆序性：(最小堆为例)所有结点都小于其后裔，根(堆顶)最小，查找最小元素秩序$O(1)$

## 2.2. 堆操作

:one:插入：先插到堆最末尾(维持完全二叉树结构)，然后上浮。以插入18为例

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240709215943635.png" alt="image-20240709215943635" style="zoom:50%;" />  

:two:建堆操作：从0开始插入。例如插入结点4, 9, 11, 5, 7, 15, 16, 18建立最大堆

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240713154717339.png" alt="image-20240713154717339" style="zoom: 42%;" />  

:three:deleteMin(删除最小堆的根节点)：删除根结点→最后一个结点放到根处→根节点开始下沉

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240709221529926.png" alt="image-20240709221529926" style="zoom: 33%;" />  

:four:dequeue(删除最大堆的根节点)：删除根结点→最后一个结点放到根处→调整堆

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240713160729717.png" alt="image-20240713160729717" style="zoom: 43%;" /> 

# 3. 渐进时间复杂度分析

:one:基本概念：当$n>>2$时

|       表达式        |          含义          |
| :-----------------: | :--------------------: |
|   $T(n)=O(f(n))$    |     $T(n)<C_2f(n)$     |
|   $T(n)=Ω(g(n))$    |     $T(n)>C_1f(n)$     |
| $T(n)=\Theta(g(n))$ | $C_1f(n)<T(n)<C_2f(n)$ |

:two:性质及其证明

1. $T_1(n)=O(f_1(n)),\,T_2(n)=O(f_2(n))\Rightarrow{}T_1(n)+T_2(n)=O(f_1(n)+f_2(n))$​  
   - $T_1(n)<C_1f_1(n),\,T_2(n)<C_2f_2(n)$ 
   - $T_1(n)+T_2(n)<C_1f_1(n)+C_2f_2(n)$​ 
   - $T_1(n)+T_2(n)<C[f_1(n)+f_2(n)],\,\,C=Max\{C_1,C_2\}$​ 
   - $T_1(n)+T_2(n)=O(f_1(n)+f_2(n))$​  
2. $n^2=\Omega(n)$
   - $T(n)=n^2,\,证明n^2=\Omega(n)$
   - $即证T(n)=n^2>Cn$​
   - $当n>>2时，显然存在C能满足条件$​ 
3. 证明$T(n)=n^2+7n-3\neq{}O(n)$
   - 假设$T(n)=n^2+7n-3=O(n)$则有$\exist{}C$使得$\,n^2+7n-3<Cn\,(n>2)$恒成立 
   - $\phi{(n)}=n^2+(7-C)n-3<0\,(n>2)$恒成立 
   - 都是开口向上的二次函数，怎么可能恒小于，假设不成立证毕
4. 证明$T(n)=n^2+7n-3=O(n^2)$ 
   - 即证$\exist{}C$使得$n^2+7n-3<Cn^2\,(n>2)$​恒成立 
   - 即$(1-C)n^2+7n-3<0\,(n>2)$
   - 即满足$\begin{cases}1-C<0\\\\\Delta=61-12C<0\end{cases}\Rightarrow{}\begin{cases}C>1\\\\C>\cfrac{61}{12}\end{cases}$
   - 故存在证毕

# 4. 二叉排序树

:one:二叉树的插入：大于值就插入右子树，小于值就插入左子树

<img src="https://api2.mubu.com/v3/document_image/08375f37-9b61-4a30-9ae8-e7fc3f0b29af-19142746.jpg" alt="img" style="zoom: 77%;" />   

:two:排序树

1. 流程：将数组按顺序插入空二叉树→对插入好的二叉树中根遍历→输出有序数组
2. 时间复杂度：假设二叉树有$T$个结点，则复杂度为$O(N\log{}T)$

